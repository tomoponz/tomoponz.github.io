<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>tomoponzï½œãƒŸãƒ‹ã‚²ãƒ¼ãƒ </title>
  <meta name="description" content="ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ï¼†2048">
  <link rel="stylesheet" href="style.css">
  <script defer src="app.js"></script>
  <style>
    /* === Games UI (site theme compatible) === */
    .tabs{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    .tabs .btn{user-select:none}
    .tabs .btn.active{border-color:rgba(124,203,255,.35); box-shadow:0 0 0 3px rgba(124,203,255,.10)}
    .gameArea{margin-top:12px}

    .hud{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; margin-top:10px}
    .hudLeft{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .hudRight{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .meter{display:flex; gap:10px; flex-wrap:wrap}
    .meter .pill{display:inline-flex; align-items:center; gap:8px}
    .tiny{font-size:12px;color:rgba(234,241,255,.70)}

    /* === Minesweeper === */
    .msWrap{display:grid; gap:12px}
    .msGrid{
      --cols:9;
      display:grid;
      grid-template-columns:repeat(var(--cols), 1fr);
      gap:6px;
      padding:12px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.03);
      box-shadow:0 18px 60px rgba(0,0,0,.25);
      touch-action:manipulation;
    }
    .cell{
      aspect-ratio:1/1;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.04);
      color:#EAF1FF;
      font-weight:700;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .cell:hover{background:rgba(255,255,255,.07)}
    .cell.revealed{
      background:rgba(255,255,255,.02);
      border-color:rgba(255,255,255,.10);
      cursor:default;
    }
    .cell.flag{border-color:rgba(255,210,124,.35); box-shadow:0 0 0 3px rgba(255,210,124,.08)}
    .cell.mine{border-color:rgba(255,124,124,.35); box-shadow:0 0 0 3px rgba(255,124,124,.08)}

    /* === 2048 === */
    .g2048Wrap{display:grid; gap:12px}
    .board{
      width:min(460px, 100%);
      margin:0 auto;
      padding:12px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.03);
      box-shadow:0 18px 60px rgba(0,0,0,.25);
    }
    .grid2048{
      display:grid;
      grid-template-columns:repeat(4, 1fr);
      gap:10px;
    }
    .tile{
      aspect-ratio:1/1;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:800;
      font-size:22px;
      user-select:none;
    }
    .tile.v0{color:transparent}
    /* 2048ã¯è‰²ã‚’æ§ãˆã‚ã«ã€å…‰ã‚Šæ–¹ã§å·®ã‚’å‡ºã™ */
    .tile.v2{box-shadow:0 0 0 3px rgba(124,203,255,.08)}
    .tile.v4{box-shadow:0 0 0 3px rgba(182,156,255,.08)}
    .tile.v8{box-shadow:0 0 0 3px rgba(124,255,178,.08)}
    .tile.v16{box-shadow:0 0 0 3px rgba(255,210,124,.10)}
    .tile.v32{box-shadow:0 0 0 3px rgba(255,124,124,.10)}
    .tile.v64{box-shadow:0 0 0 3px rgba(255,124,124,.14)}
    .tile.v128,.tile.v256,.tile.v512,.tile.v1024,.tile.v2048{box-shadow:0 0 0 3px rgba(124,255,178,.14)}
  </style>
</head>
<body>
  <header class="nav">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <b>tomoponz</b><br><small>ãƒŸãƒ‹ã‚²ãƒ¼ãƒ </small>
      </div>
    </div>
    <nav class="navlinks">
      <a class="chip" href="index.html">ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«</a>
      <a class="chip" href="omikuji.html">ãŠã¿ãã˜</a>
      <a class="chip" href="shindan.html">è¨ºæ–­</a>
      <a class="chip" href="gallery.html">ãƒã‚¿ç½®ãå ´</a>
      <a class="chip" href="links.html">ãƒªãƒ³ã‚¯</a>
      <a class="chip" href="games.html">ã‚²ãƒ¼ãƒ </a>
    </nav>
  </header>

  <main class="wrap">
    <section class="hero">
      <h1 class="h1">ãƒŸãƒ‹ã‚²ãƒ¼ãƒ </h1>
      <p class="sub">ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã¨2048ã€‚å‹é”ã«æŠ•ã’ã¦æ™‚é–“ã‚’æº¶ã‹ã›ã€‚</p>
      <div class="note">ã‚¹ãƒãƒ›ã§ã‚‚éŠã¹ã‚‹ã€‚ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã¯ã€Œæ——ãƒ¢ãƒ¼ãƒ‰ã€ã§æ“ä½œã—ã‚„ã™ãã—ã¦ã‚ã‚‹ã€‚</div>

      <div class="tabs">
        <button class="btn active" id="tab-ms" onclick="showTab('ms')">ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</button>
        <button class="btn" id="tab-2048" onclick="showTab('2048')">2048</button>
        <a class="btn" href="gallery.html">ãƒã‚¿ç½®ãå ´ã¸æˆ»ã‚‹</a>
      </div>
    </section>

    <!-- Minesweeper -->
    <section class="gameArea" id="pane-ms">
      <div class="grid2">
        <div class="card">
          <h2>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</h2>
          <p class="muted">å·¦ã‚¯ãƒªãƒƒã‚¯ï¼šé–‹ã / å³ã‚¯ãƒªãƒƒã‚¯ï¼šæ——ï¼ˆã‚¹ãƒãƒ›ã¯ã€Œæ——ãƒ¢ãƒ¼ãƒ‰ã€ï¼‰</p>

          <div class="hud">
            <div class="hudLeft">
              <span class="pill">é›£æ˜“åº¦ï¼š
                <select id="msDiff" style="margin-left:8px;background:transparent;color:inherit;border:1px solid rgba(255,255,255,.16);border-radius:10px;padding:6px 10px">
                  <option value="easy">EASY 9Ã—9 / 10</option>
                  <option value="mid">MID 12Ã—12 / 24</option>
                  <option value="hard">HARD 16Ã—16 / 40</option>
                </select>
              </span>
              <button onclick="msNew()">æ–°ã—ãé–‹å§‹</button>
              <button id="msFlagBtn" onclick="msToggleFlagMode()">æ——ãƒ¢ãƒ¼ãƒ‰ï¼šOFF</button>
            </div>

            <div class="hudRight meter">
              <span class="pill">ğŸ’£ æ®‹ã‚Šï¼š<b id="msMinesLeft">10</b></span>
              <span class="pill">â± <b id="msTime">0</b>s</span>
              <span class="pill">çŠ¶æ…‹ï¼š<b id="msState">é€²è¡Œä¸­</b></span>
            </div>
          </div>

          <div class="msWrap" style="margin-top:12px">
            <div class="msGrid" id="msGrid" style="--cols:9"></div>
            <div class="note tiny">ã‚³ãƒ„ï¼šæ•°å­—ã¯å‘¨å›²8ãƒã‚¹ã®åœ°é›·æ•°ã€‚0ã¯é€£é–ã§é–‹ãã€‚</div>
          </div>
        </div>

        <div class="card">
          <h2>å‹é”ç”¨èª¬æ˜ï¼ˆé›‘ã«ï¼‰</h2>
          <ul class="list">
            <li>ã¾ãšã€Œæ–°ã—ãé–‹å§‹ã€æŠ¼ã›ã€‚</li>
            <li>æ•°å­—ï¼å‘¨ã‚Šã®åœ°é›·æ•°ã€‚</li>
            <li>åœ°é›·è¸ã‚“ã ã‚‰è² ã‘ã€‚å‹ã£ãŸã‚‰è‡ªæ…¢ã€‚</li>
          </ul>
          <hr class="sep">
          <div class="note">ã‚¹ãƒãƒ›ã¯ã€Œæ——ãƒ¢ãƒ¼ãƒ‰ONã€ã«ã—ã¦ã€ã‚¿ãƒƒãƒ—ã§æ——â†’ã‚‚ã†ä¸€åº¦ã§æˆ»ã™ã€‚</div>
        </div>
      </div>
    </section>

    <!-- 2048 -->
    <section class="gameArea" id="pane-2048" style="display:none">
      <div class="grid2">
        <div class="card">
          <h2>2048</h2>
          <p class="muted">PCï¼šçŸ¢å°ã‚­ãƒ¼ / ã‚¹ãƒãƒ›ï¼šã‚¹ãƒ¯ã‚¤ãƒ—</p>

          <div class="hud">
            <div class="hudLeft">
              <button onclick="gNew()">ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            </div>
            <div class="hudRight meter">
              <span class="pill">Scoreï¼š<b id="gScore">0</b></span>
              <span class="pill">Bestï¼š<b id="gBest">0</b></span>
              <span class="pill">çŠ¶æ…‹ï¼š<b id="gState">é€²è¡Œä¸­</b></span>
            </div>
          </div>

          <div class="g2048Wrap" style="margin-top:12px">
            <div class="board" id="gBoard">
              <div class="grid2048" id="gGrid"></div>
            </div>
            <div class="note tiny">åŒã˜æ•°å­—ã‚’ã¶ã¤ã‘ã¦å€ã«ã™ã‚‹ã€‚2048ä½œã‚ŒãŸã‚‰å‹ã¡ï¼ˆã§ã‚‚ç¶šã‘ã¦ã‚‚è‰¯ã„ï¼‰ã€‚</div>
          </div>
        </div>

        <div class="card">
          <h2>å‹é”ã«è¨€ã†ä¸€è¨€</h2>
          <p class="muted">ã€Œã“ã®ã‚µã‚¤ãƒˆã€éŸ³æ¥½ã¨åœ°é›·ã¨æ•°å­—ã—ã‹ãªã„ã€‚æœ€é«˜ã€‚ã€</p>
          <hr class="sep">
          <div class="note">2048ã¯â€œè§’â€ã«æœ€å¤§æ•°ã‚’å›ºå®šã™ã‚‹ã®ãŒåŸºæœ¬æˆ¦è¡“ã€‚</div>
        </div>
      </div>
    </section>

    <div class="footer">Â© tomoponz / Mini Games</div>
  </main>

  <script>
    // ===== Tabs =====
    function showTab(which){
      const ms = document.getElementById('pane-ms');
      const g  = document.getElementById('pane-2048');
      const t1 = document.getElementById('tab-ms');
      const t2 = document.getElementById('tab-2048');
      if(which === 'ms'){
        ms.style.display = '';
        g.style.display = 'none';
        t1.classList.add('active');
        t2.classList.remove('active');
      }else{
        ms.style.display = 'none';
        g.style.display = '';
        t2.classList.add('active');
        t1.classList.remove('active');
      }
    }

    // =========================
    // ===== Minesweeper =======
    // =========================
    let msW=9, msH=9, msM=10;
    let msMine=[], msAdj=[], msRev=[], msFlag=[];
    let msOver=false, msWin=false;
    let msFlags=0, msStart=false, msTimer=null, msTime=0;
    let msFlagMode=false;

    const msGridEl = document.getElementById('msGrid');
    const msMinesLeftEl = document.getElementById('msMinesLeft');
    const msTimeEl = document.getElementById('msTime');
    const msStateEl = document.getElementById('msState');
    const msDiffEl = document.getElementById('msDiff');
    const msFlagBtn = document.getElementById('msFlagBtn');

    function msSetDiff(){
      const v = msDiffEl.value;
      if(v==='easy'){ msW=9; msH=9; msM=10; }
      if(v==='mid'){ msW=12; msH=12; msM=24; }
      if(v==='hard'){ msW=16; msH=16; msM=40; }
    }

    function idx(x,y){ return y*msW + x; }
    function inb(x,y){ return x>=0 && y>=0 && x<msW && y<msH; }

    function msResetTimer(){
      if(msTimer){ clearInterval(msTimer); msTimer=null; }
      msTime=0; msTimeEl.textContent = msTime;
      msStart=false;
    }
    function msStartTimer(){
      if(msStart) return;
      msStart=true;
      msTimer = setInterval(()=>{ msTime++; msTimeEl.textContent = msTime; }, 1000);
    }

    function msNew(){
      msSetDiff();
      msOver=false; msWin=false;
      msFlags=0;
      msMine = Array(msW*msH).fill(false);
      msAdj  = Array(msW*msH).fill(0);
      msRev  = Array(msW*msH).fill(false);
      msFlag = Array(msW*msH).fill(false);
      msResetTimer();
      msFlagMode=false;
      msFlagBtn.textContent = "æ——ãƒ¢ãƒ¼ãƒ‰ï¼šOFF";
      msStateEl.textContent = "é€²è¡Œä¸­";
      msMinesLeftEl.textContent = msM;

      // build grid
      msGridEl.style.setProperty('--cols', msW);
      msGridEl.innerHTML = '';
      for(let y=0;y<msH;y++){
        for(let x=0;x<msW;x++){
          const b = document.createElement('div');
          b.className = 'cell';
          b.dataset.x = x;
          b.dataset.y = y;
          b.oncontextmenu = (e)=>{ e.preventDefault(); msToggleFlag(x,y); };
          b.addEventListener('click', ()=>{ msClick(x,y); });
          msGridEl.appendChild(b);
        }
      }
    }

    function msPlaceMines(sx,sy){
      // avoid first click cell
      let placed=0;
      while(placed<msM){
        const r = Math.floor(Math.random()*msW*msH);
        const x = r % msW, y = Math.floor(r/msW);
        if(msMine[r]) continue;
        if(x===sx && y===sy) continue;
        msMine[r]=true;
        placed++;
      }
      // compute adj
      for(let y=0;y<msH;y++){
        for(let x=0;x<msW;x++){
          const i = idx(x,y);
          if(msMine[i]){ msAdj[i]=0; continue; }
          let c=0;
          for(let dy=-1;dy<=1;dy++){
            for(let dx=-1;dx<=1;dx++){
              if(dx===0 && dy===0) continue;
              const nx=x+dx, ny=y+dy;
              if(inb(nx,ny) && msMine[idx(nx,ny)]) c++;
            }
          }
          msAdj[i]=c;
        }
      }
    }

    function cellEl(x,y){
      return msGridEl.children[idx(x,y)];
    }

    function msRenderCell(x,y){
      const i = idx(x,y);
      const el = cellEl(x,y);
      el.classList.toggle('revealed', msRev[i]);
      el.classList.toggle('flag', msFlag[i]);
      el.classList.remove('mine');

      if(!msRev[i]){
        el.textContent = msFlag[i] ? "ğŸš©" : "";
        return;
      }

      if(msMine[i]){
        el.classList.add('mine');
        el.textContent = "ğŸ’£";
        return;
      }

      const n = msAdj[i];
      el.textContent = (n===0) ? "" : String(n);
    }

    function msToggleFlag(x,y){
      if(msOver) return;
      const i = idx(x,y);
      if(msRev[i]) return;
      msFlag[i] = !msFlag[i];
      msFlags += msFlag[i] ? 1 : -1;
      msMinesLeftEl.textContent = msM - msFlags;
      msRenderCell(x,y);
      msCheckWin();
    }

    function msReveal(x,y){
      const i = idx(x,y);
      if(msRev[i] || msFlag[i]) return;
      msRev[i]=true;
      msRenderCell(x,y);

      if(msAdj[i]===0 && !msMine[i]){
        // BFS reveal empties
        const q = [[x,y]];
        while(q.length){
          const [cx,cy] = q.shift();
          for(let dy=-1;dy<=1;dy++){
            for(let dx=-1;dx<=1;dx++){
              const nx=cx+dx, ny=cy+dy;
              if(!inb(nx,ny)) continue;
              const ni = idx(nx,ny);
              if(msRev[ni] || msFlag[ni]) continue;
              msRev[ni]=true;
              msRenderCell(nx,ny);
              if(msAdj[ni]===0 && !msMine[ni]) q.push([nx,ny]);
            }
          }
        }
      }
    }

    function msClick(x,y){
      if(msOver) return;

      if(msFlagMode){
        msToggleFlag(x,y);
        return;
      }

      const i = idx(x,y);
      if(msFlag[i]) return;

      if(!msStart){
        msPlaceMines(x,y);
        msStartTimer();
      }

      msReveal(x,y);

      if(msMine[i]){
        msGameOver(false);
        return;
      }
      msCheckWin();
    }

    function msGameOver(win){
      msOver=true;
      msWin=win;
      if(msTimer){ clearInterval(msTimer); msTimer=null; }
      msStateEl.textContent = win ? "å‹åˆ©" : "çˆ†æ­»";

      // reveal all mines on lose
      if(!win){
        for(let y=0;y<msH;y++){
          for(let x=0;x<msW;x++){
            const i = idx(x,y);
            if(msMine[i]){
              msRev[i]=true;
              msRenderCell(x,y);
            }
          }
        }
      }
    }

    function msCheckWin(){
      if(msOver) return;
      // win if all non-mines revealed
      let ok=true;
      for(let i=0;i<msW*msH;i++){
        if(!msMine[i] && !msRev[i]){ ok=false; break; }
      }
      if(ok) msGameOver(true);
    }

    function msToggleFlagMode(){
      msFlagMode = !msFlagMode;
      msFlagBtn.textContent = "æ——ãƒ¢ãƒ¼ãƒ‰ï¼š" + (msFlagMode ? "ON" : "OFF");
    }

    msDiffEl.addEventListener('change', msNew);
    msNew();

    // =====================
    // ===== 2048 ==========
    // =====================
    const size=4;
    let grid=[], score=0, best=0, gOver=false;

    const gGridEl = document.getElementById('gGrid');
    const gScoreEl = document.getElementById('gScore');
    const gBestEl = document.getElementById('gBest');
    const gStateEl = document.getElementById('gState');
    const gBoardEl = document.getElementById('gBoard');

    function gLoadBest(){
      const b = Number(localStorage.getItem('best2048')||'0');
      best = isNaN(b)?0:b;
      gBestEl.textContent = best;
    }
    function gSaveBest(){
      if(score>best){
        best=score;
        localStorage.setItem('best2048', String(best));
        gBestEl.textContent = best;
      }
    }

    function gEmptyCells(){
      const res=[];
      for(let r=0;r<size;r++){
        for(let c=0;c<size;c++){
          if(grid[r][c]===0) res.push([r,c]);
        }
      }
      return res;
    }
    function gSpawn(){
      const empt = gEmptyCells();
      if(empt.length===0) return;
      const [r,c] = empt[Math.floor(Math.random()*empt.length)];
      grid[r][c] = (Math.random()<0.9) ? 2 : 4;
    }

    function gRender(){
      gGridEl.innerHTML='';
      for(let r=0;r<size;r++){
        for(let c=0;c<size;c++){
          const v = grid[r][c];
          const d = document.createElement('div');
          d.className = 'tile v'+v;
          d.textContent = v===0 ? '.' : String(v);
          if(v===0) d.classList.add('v0');
          gGridEl.appendChild(d);
        }
      }
      gScoreEl.textContent = score;
      gSaveBest();
    }

    function gCanMove(){
      if(gEmptyCells().length>0) return true;
      for(let r=0;r<size;r++){
        for(let c=0;c<size;c++){
          const v=grid[r][c];
          if(r+1<size && grid[r+1][c]===v) return true;
          if(c+1<size && grid[r][c+1]===v) return true;
        }
      }
      return false;
    }

    function gHas2048(){
      for(let r=0;r<size;r++){
        for(let c=0;c<size;c++){
          if(grid[r][c]===2048) return true;
        }
      }
      return false;
    }

    function slideLine(line){
      // remove zeros
      const arr = line.filter(x=>x!==0);
      // merge
      for(let i=0;i<arr.length-1;i++){
        if(arr[i]===arr[i+1]){
          arr[i]*=2;
          score += arr[i];
          arr[i+1]=0;
        }
      }
      const merged = arr.filter(x=>x!==0);
      while(merged.length<size) merged.push(0);
      return merged;
    }

    function gMove(dir){
      if(gOver) return;
      const before = JSON.stringify(grid);

      if(dir==='left'){
        for(let r=0;r<size;r++){
          grid[r] = slideLine(grid[r]);
        }
      }
      if(dir==='right'){
        for(let r=0;r<size;r++){
          const rev = [...grid[r]].reverse();
          grid[r] = slideLine(rev).reverse();
        }
      }
      if(dir==='up'){
        for(let c=0;c<size;c++){
          const col = [];
          for(let r=0;r<size;r++) col.push(grid[r][c]);
          const slid = slideLine(col);
          for(let r=0;r<size;r++) grid[r][c] = slid[r];
        }
      }
      if(dir==='down'){
        for(let c=0;c<size;c++){
          const col = [];
          for(let r=0;r<size;r++) col.push(grid[r][c]);
          const rev = col.reverse();
          const slid = slideLine(rev).reverse();
          for(let r=0;r<size;r++) grid[r][c] = slid[r];
        }
      }

      const after = JSON.stringify(grid);
      if(before !== after){
        gSpawn();
        gRender();
        if(gHas2048()) gStateEl.textContent = "2048é”æˆ";
        if(!gCanMove()){
          gOver=true;
          gStateEl.textContent = "è©°ã¿";
        }
      }
    }

    function gNew(){
      grid = Array.from({length:size}, ()=>Array(size).fill(0));
      score=0; gOver=false;
      gStateEl.textContent = "é€²è¡Œä¸­";
      gLoadBest();
      gSpawn(); gSpawn();
      gRender();
    }

    // keyboard
    window.addEventListener('keydown', (e)=>{
      const k = e.key;
      if(k==='ArrowLeft'){ e.preventDefault(); gMove('left'); }
      if(k==='ArrowRight'){ e.preventDefault(); gMove('right'); }
      if(k==='ArrowUp'){ e.preventDefault(); gMove('up'); }
      if(k==='ArrowDown'){ e.preventDefault(); gMove('down'); }
    }, {passive:false});

    // swipe
    let sx=0, sy=0, st=0;
    gBoardEl.addEventListener('touchstart', (e)=>{
      if(!e.touches || !e.touches[0]) return;
      sx = e.touches[0].clientX;
      sy = e.touches[0].clientY;
      st = Date.now();
    }, {passive:true});

    gBoardEl.addEventListener('touchend', (e)=>{
      const t = e.changedTouches && e.changedTouches[0];
      if(!t) return;
      const dx = t.clientX - sx;
      const dy = t.clientY - sy;
      const dt = Date.now() - st;
      if(dt > 800) return;
      if(Math.abs(dx) < 25 && Math.abs(dy) < 25) return;

      if(Math.abs(dx) > Math.abs(dy)){
        gMove(dx>0 ? 'right' : 'left');
      }else{
        gMove(dy>0 ? 'down' : 'up');
      }
    }, {passive:true});

    gNew();
  </script>
</body>
</html>
